<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="view-transition" content="same-origin">
    <meta name="description" content="Why pandas .loc[] can be surprisingly slow and what to use instead. Benchmarks comparing loc, at, iloc, iat vs plain dict.">
    <title>The Hidden Performance Trap in pandas.loc[] | Petr Dvořáček</title>
    <link rel="canonical" href="https://petrdvoracek.github.io/blog/pandas-loc-performance.html">

    <!-- Open Graph -->
    <meta property="og:title" content="The Hidden Performance Trap in pandas.loc[]">
    <meta property="og:description" content="Why pandas .loc[] can be surprisingly slow and what to use instead. Benchmarks show 4-24x speedup with plain dict.">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://petrdvoracek.github.io/blog/pandas-loc-performance.html">

    <!-- Favicon -->
    <link rel="icon" href="/favicon.ico" sizes="32x32">
    <link rel="icon" href="/favicon.svg" type="image/svg+xml">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="../style.css">

    <!-- Preload header image to prevent flicker -->
    <link rel="preload" as="image" href="/me.jpg">

    <!-- Syntax highlighting -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>
    <script>document.addEventListener('DOMContentLoaded', () => hljs.highlightAll());</script>
</head>
<body>
    <header class="site-header">
        <img src="/me.jpg" alt="Petr Dvořáček" class="photo" width="48" height="48" fetchpriority="high">
        <div class="identity">
            <a href="../index.html" class="name">Petr Dvořáček</a>
        </div>
        <nav>
            <a href="../index.html">Home</a>
            <a href="../blog.html" class="active">Blog</a>
        </nav>
    </header>

    <a href="../blog.html" class="back">Back to blog</a>

    <article>
        <h1>The Hidden Performance Trap in pandas.loc[]</h1>
        <p class="meta">January 16, 2026</p>

        <p>
            Recently I came across production code where pandas' <code>.loc[]</code> was
            being used in a tight loop to access rows repeatedly. The performance was,
            unsurprisingly, poor. That's counterintuitive &ndash; if you've set the DataFrame index to
            your lookup key, accessing a value by that key should be fast, right? Wrong.
        </p>

        <h2>The Problem</h2>
        <p>
            When accessing single values repeatedly, <code>.loc[]</code> carries significant overhead.
            Each call handles label lookup, type checking, and complex slicing operations
            you're not even using. For scalar access, this is wasteful.
        </p>

        <h2>Benchmark: loc vs at vs iloc vs iat vs dict</h2>
        <p>
            Here's a benchmark you can run yourself. It tests not only <code>.loc[]</code> but
            also <code>.at[]</code>, <code>.iloc[]</code>, <code>.iat[]</code>, and plain Python <code>dict</code> lookups. <code>loc[]</code>
             and <code>at[]</code> are string-based, while <code>iloc[]</code> and <code>iat[]</code> are position-based. 
             Benchmark runs 10,000 random lookups on a DataFrame with 1 million rows:
        </p>

        <pre><code class="language-python">import pandas as pd
import numpy as np
import random
import time

NUM_ITEMS = 1_000_000
NUM_LOOKUPS = 10_000

num_classes = 10

# Create test data, each img_X maps to a random class
data = {
    f"img_{i}": np.random.randint(num_classes) for i in range(NUM_ITEMS)
    }
keys = list(data.keys())

# Create DataFrame with test data
df = pd.DataFrame(
    {"value": data.values()},
    index=data.keys() # this should be fast, right?
    )
# Warm-up access to avoid any lazy initialization overhead
_ = df.loc[keys[0]]
_ = df.at[keys[0], "value"]
_ = df.iloc[0]
_ = df.iat[0, 0]

# Generate random queries for lookup
lookup_keys = [random.choice(keys) for _ in range(NUM_LOOKUPS)]
lookup_indices = [
    random.randint(0, NUM_ITEMS - 1) for _ in range(NUM_LOOKUPS)
    ]

# Benchmark: dict lookup
start = time.perf_counter()
for key in lookup_keys:
    _ = data[key]
dict_time = time.perf_counter() - start

# Benchmark: pandas .loc lookup (label-based)
start = time.perf_counter()
for key in lookup_keys:
    _ = df.loc[key]
loc_time = time.perf_counter() - start

# Benchmark: pandas .at lookup (label-based, scalar)
start = time.perf_counter()
for key in lookup_keys:
    _ = df.at[key, "value"]
at_time = time.perf_counter() - start

# Benchmark: pandas .iloc lookup (integer position-based)
start = time.perf_counter()
for idx in lookup_indices:
    _ = df.iloc[idx]
iloc_time = time.perf_counter() - start

# Benchmark: pandas .iat lookup (integer position-based, scalar)
start = time.perf_counter()
for idx in lookup_indices:
    _ = df.iat[idx, 0]
iat_time = time.perf_counter() - start

print(f"dict:  {dict_time:.4f}s")
print(f"loc:   {loc_time:.4f}s  "
      f"({loc_time / dict_time:5.1f}x slower than dict)")
print(f"at:    {at_time:.4f}s  "
      f"({at_time / dict_time:5.1f}x slower than dict)")
print(f"iloc:  {iloc_time:.4f}s  "
      f"({iloc_time / dict_time:5.1f}x slower than dict)")
print(f"iat:   {iat_time:.4f}s  "
      f"({iat_time / dict_time:5.1f}x slower than dict)")
</code></pre>

        <h2>Typical Results</h2>
        <p>
            Running this on MacBook Pro M4 (pandas 2.3.3, Python 3.13.5) yields:
        </p>

        <pre><code class="language-plaintext">dict:  0.0025s
loc:   0.0543s  ( 21.3x slower than dict)
at:    0.0127s  (  5.0x slower than dict)
iloc:  0.0493s  ( 19.3x slower than dict)
iat:   0.0417s  ( 16.3x slower than dict)</code></pre>

        <p>
            The difference is stark. With 1 million rows, <code>.loc[]</code> is over 21x slower than a plain dict.
            Even <code>.at[]</code>, the fastest pandas accessor, is still 5x slower.
            The position-based methods (<code>.iloc[]</code>, <code>.iat[]</code>) are
            surprisingly slow as well.
        </p>

        <p>
            <strong>A note on vectorization:</strong> The production code I encountered genuinely
            required element-wise lookups &ndash; it was embedded in a dataset iterator. In this 
            case, vectorization wasn't an option.
        </p>

        <h2>Takeaways</h2>
        <ul>
            <li>For key-value lookups in loops, convert DataFrame to a plain dict (5&ndash;20x faster than pandas)</li>
            <li>If you must use pandas for scalar access, prefer <code>.at[]</code> over <code>.loc[]</code></li>
            <li>For bulk operations, always vectorize</li>
        </ul>

        <h2>References</h2>
        <ul>
            <li><a href="https://github.com/pandas-dev/pandas/issues/54550">GitHub Issue #54550: Unreliable performance of .loc with non-unique index</a></li>
            <li><a href="https://github.com/pandas-dev/pandas/issues/6683">GitHub Issue #6683: Poor performance for .loc and .iloc</a></li>
        </ul>

    </article>

    <footer>
        <p>Petr Dvořáček · <a href="mailto:pedro.dvoracek@gmail.com">pedro.dvoracek@gmail.com</a></p>
    </footer>
<!-- Cloudflare Web Analytics --><script defer src='https://static.cloudflareinsights.com/beacon.min.js' data-cf-beacon='{"token": "6f893c39c896459da341bb0145f4e85e"}'></script><!-- End Cloudflare Web Analytics -->
</body>
</html>

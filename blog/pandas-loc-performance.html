<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Why pandas .loc[] can be surprisingly slow and what to use instead. Benchmarks comparing loc, at, iloc, iat vs plain dict.">
    <title>The Hidden Performance Trap in pandas.loc[] | Petr Dvořáček</title>
    <link rel="canonical" href="https://petrdvoracek.github.io/blog/pandas-loc-performance.html">

    <!-- Open Graph -->
    <meta property="og:title" content="The Hidden Performance Trap in pandas.loc[]">
    <meta property="og:description" content="Why pandas .loc[] can be surprisingly slow and what to use instead. Benchmarks show 4-24x speedup with plain dict.">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://petrdvoracek.github.io/blog/pandas-loc-performance.html">

    <!-- Favicon -->
    <link rel="icon" href="/favicon.ico" sizes="32x32">
    <link rel="icon" href="/favicon.svg" type="image/svg+xml">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <a href="../blog.html" class="back">Back to blog</a>

    <article>
        <h1>The Hidden Performance Trap in pandas.loc[]</h1>
        <p class="meta">January 16, 2026</p>

        <blockquote class="pull-quote">
            Stop using pandas <code>.loc[]</code>. Please.
        </blockquote>

        <p>
            Recently I have came across a production code where pandas' <code>.loc[]</code> was
            being used in a tight loop to access single values repeatedly. The performance was,
            unsurprisingly, poor. That is counter intuitive, since you have set the dataframe to
            index by the lookup key, so accessing a value by that key should be fast, right? Wrong.
        </p>

        <h2>The Problem</h2>
        <p>
            When accessing single values repeatedly, <code>.loc[]</code> carries significant overhead.
            Each call must handle label lookup, type checking, and support for complex slicing operations
            you're not even using. For scalar access, this is wasteful.
        </p>

        <h2>Benchmark: loc vs at vs iat vs iloc vs dictionary</h2>
        <p>
            Here's a simple benchmark you can run yourself. We'll access a single cell 10,000 times
            using different methods:
        </p>

        <pre><code>import pandas as pd
import numpy as np
import random
import time

NUM_ITEMS = 10_000_000
NUM_LOOKUPS = 10_000
num_classes = 10

# Create test data: each img_X maps to a random class
data = {
    f"img_{i}": np.random.randint(num_classes)
    for i in range(NUM_ITEMS)
}
keys = list(data.keys())

# Create DataFrame with same data
# Indexed by img_X keys - should be fast, right?
df = pd.DataFrame(
    {"value": data.values()},
    index=data.keys()
)

# Generate random queries for lookup
lookup_keys = [
    random.choice(keys) for _ in range(NUM_LOOKUPS)
]
lookup_indices = [
    random.randint(0, NUM_ITEMS - 1)
    for _ in range(NUM_LOOKUPS)
]

# Benchmark: dict lookup
start = time.perf_counter()
for key in lookup_keys:
    _ = data[key]
dict_time = time.perf_counter() - start

# Benchmark: pandas .loc lookup (label-based)
start = time.perf_counter()
for key in lookup_keys:
    _ = df.loc[key, "value"]
loc_time = time.perf_counter() - start

# Benchmark: pandas .at lookup (scalar)
start = time.perf_counter()
for key in lookup_keys:
    _ = df.at[key, "value"]
at_time = time.perf_counter() - start

# Benchmark: pandas .iloc lookup (position-based)
start = time.perf_counter()
for idx in lookup_indices:
    _ = df.iloc[idx, 0]
iloc_time = time.perf_counter() - start

# Benchmark: pandas .iat lookup (scalar)
start = time.perf_counter()
for idx in lookup_indices:
    _ = df.iat[idx, 0]
iat_time = time.perf_counter() - start

# Results
print(f"dict:  {dict_time:.4f}s")
print(f"loc:   {loc_time:.4f}s")
print(f"at:    {at_time:.4f}s")
print(f"iloc:  {iloc_time:.4f}s")
print(f"iat:   {iat_time:.4f}s")</code></pre>

        <h2>Typical Results</h2>
        <p>
            Running this on Macbook Pro M4 (pandas 2.x, Python 3.11):
        </p>

        <pre><code>dict:  0.0036s
loc:   1.9263s  (532.6x slower than dict)
at:    0.0137s  (  3.8x slower than dict)
iloc:  0.0532s  ( 14.7x slower than dict)
iat:   0.0386s  ( 10.7x slower than dict)</code></pre>

        <p>
            The difference is stark. With 10 million rows, <code>.loc[]</code> is dramatically
            slower than everything else &ndash; over 533x slower than a plain dict. Even
            <code>.at[]</code>, the fastest pandas accessor, is still 4x slower than dict.
            The position-based methods (<code>.iloc[]</code>, <code>.iat[]</code>) fall
            somewhere in between.
        </p>

        <p>
            <strong>A note on vectorization:</strong> The production code I encountered genuinely
            required element-wise lookups &ndash; it was embedded in dataset iterator. But more
            often than not, what looks like a loop can be rewritten
            as a vectorized operation, which will be orders of magnitude faster than any
            element-wise approach.
        </p>

        

        <h2>Why This Happens</h2>
        <p>
            The reason is simple: <code>.loc[]</code> and <code>.iloc[]</code> are general-purpose
            accessors. They handle:
        </p>
        <ul>
            <li>Single values, rows, columns, and arbitrary slices</li>
            <li>Boolean masks and callable indexers</li>
            <li>MultiIndex navigation</li>
            <li>Duplicate index handling</li>
            <li>Type coercion and validation</li>
        </ul>
        <p>
            All that flexibility comes at a cost. When you only need a single scalar value,
            you're paying for features you don't use.
        </p>

        <h2>The Fix</h2>
        <p>
            Use the right tool for the job:
        </p>
        <ul>
            <li><strong>Plain dict</strong> for key-value lookups in loops (fastest)</li>
            <li><strong><code>.at[row, col]</code></strong> for single scalar by label if you must use pandas</li>
            <li><strong><code>.loc[]</code></strong> for slices, boolean masks, or multi-row/column access</li>
            <li><strong><code>.iloc[]</code>/<code>.iat[]</code></strong> for position-based access (but note they're slower than label-based)</li>
        </ul>

        <h2>Takeaways</h2>
        <ul>
            <li>For key-value lookups in loops: use a plain dict (4-24x faster than pandas)</li>
            <li>If you must use pandas for scalar access: <code>.at[]</code> over <code>.loc[]</code></li>
            <li>For bulk operations: always vectorize</li>
            <li>Profile before optimizing &ndash; the bottleneck is rarely where you think</li>
        </ul>

        <h2>References</h2>
        <ul>
            <li><a href="https://github.com/pandas-dev/pandas/issues/54550">GitHub Issue #54550: Unreliable performance of .loc with non-unique index</a></li>
            <li><a href="https://github.com/pandas-dev/pandas/issues/6683">GitHub Issue #6683: Poor performance for .loc and .iloc</a></li>
            <li><a href="https://pandas.pydata.org/docs/user_guide/enhancingperf.html">pandas documentation: Enhancing performance</a></li>
        </ul>

    </article>

    <footer>
        <a href="../blog.html">&larr; Back to blog</a>
    </footer>
</body>
</html>
